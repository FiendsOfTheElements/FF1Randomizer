@using System.ComponentModel;
@using System.IO;
@using System.Web;
@using RomUtilities;
@using FF1Lib;
@using System.Text.Json;
@using BlazorStrap
@using Microsoft.AspNetCore.Components.Web
@using FF1Lib.Procgen;
@using System.IO.Compression
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage
@inject HttpClient Http


<div id="generate" class="framed-content">
	@if (showChaos)
	{
		<h3 class="centered">You spawned Chaos!</h3>
		<p>You REALLY love clicking orbs...</p>
		<img style="width: 100%" src="/images/orbs-easter-egg.png" />
	}


	<h3 class="centered">Randomize</h3>

	<p>@RomMessage</p>
	<input type="file" id="fileInput" accept=".nes" @onchange="@OnFileChanged" />
	<div class="checkbox-cell"></div>
	<CheckBox UpdateAction="@UpdateAction" Id="rememberCheckBox" @bind-Value="RememberROM">Remember ROM</CheckBox>
	<CheckBox UpdateAction="@UpdateAction" Id="tournamentSafeCheckBox" @bind-Value="Flags.TournamentSafe">Tournament Safe ROM</CheckBox>
	<CheckBox UpdateAction="@UpdateAction" Id="spoilersCheckBox" @bind-Value="Flags.Spoilers">Generate Spoiler Log!</CheckBox>
	<CheckBox UpdateAction="@UpdateAction" Id="printBlursingsCheckBox" @bind-Value="Preferences.PrintBlursings">Print Class Blursings</CheckBox>
	<CheckBox UpdateAction="@UpdateAction" Id="tristatesCheckBox" @bind-Value="Flags.TriState">Show Reveal Randomized State Flags Button</CheckBox>
	<CheckBox UpdateAction="@UpdateAction" Id="blindseedCheckBox" IsEnabled="@(!Flags.BlindSeed)" @bind-Value="Flags.BlindSeed">Hide Flags</CheckBox>
	<p>
		Seed:
		<br>
		<input type="text" style="width: calc(100% - 80px);" class="nes-input @(_seedInputClass)" id="seedInput" @onchange="@OnSeedInputChanged" value="@(_seed)" />
		<a class="styled-button" @onclick="@OnNewSeed">New</a>
	</p>

	<p>
		Flags:
		<br>
		<input style="width: calc(100% - 80px);" type="text" class="nes-input" value="@Flagstring" @onchange="@OnFlagsInputChanged" />
		<a class="styled-button" @onclick="@OnCopyToClipboard">Export</a>
	</p>

	@if (Flags.Archipelago)
	{
		<p>
			Archipelago Player Name:
			<br>
				<input type="text" style="width: calc(100% - 80px);" class="nes-input" maxlength="16" @onchange="@OnPlayerNameChanged" value="@(Preferences.PlayerName)" />
		</p>
	}

	@if (!Flags.BlindSeed)
	{
		<p>
			<ToolTipBox UpdateAction="@UpdateAction" Id="importResourcePack"><strong>Import Resource Pack</strong></ToolTipBox>
			Resource Pack URL:
			<br>
			<input type="text" style="width: calc(100% - 80px);" class="nes-input" id="setResourcePackUrlInput" value="@ResourcePackUrl" @onchange="@OnResourcePackUrlChanged" />
			<a class="styled-button" @onclick="@OnClearResourcePackUrl">Clear</a>
			<br><br>
			Upload Resource Pack:
			<br>
			<input type="file" id="importResourcePackInput" accept=".zip" @onchange="@OnImportResourcePack" />
		</p>
	}

	<p>@((MarkupString)StatusMessage)</p>
	<div class="row">&nbsp;</div>
	<a class="styled-button generate-button" hidden="@(!Flags.TriState)" disabled="@(!Flags.TriState)" style="font-size: small; margin-bottom: 10px;" @onclick="@CollapseTriStates">Reveal Randomized State Flags</a>
	<a class="styled-button generate-button" @onclick="@OnRandomize">Generate ROM</a>
</div>


@code {
	[Parameter] public FF1Lib.Flags Flags { get; set; }
	[Parameter] public FF1Lib.Preferences Preferences { get; set; }
	[Parameter] public Action<string> SetStatusMessage { get; set; }
	[Parameter] public string StatusMessage { get; set; }
	[Parameter] public Action<string, MouseEventArgs> UpdateToolTipID { get; set; }
	[Parameter]	public Action<string, string> UpdateAction { get; set; }
	[Parameter] public bool IsOpen { get; set; } = true;
	[Parameter] public bool showChaos { get; set; }
	[Parameter] public string Flagstring { get; set; }
	[Parameter] public string ResourcePackUrl { get; set; }
	[Parameter] public Action<string> UpdateSeed { get; set; }
	[CascadingParameter(Name="ShowModal")] public MainLayout.ShowModalT ShowModal { get; set; }
	[CascadingParameter(Name="SetGenerating")] public MainLayout.ShowModalT SetGenerating { get; set; }
	[CascadingParameter(Name="SetModalContent")] public MainLayout.SetContentT SetModalContent { get; set; }
	[CascadingParameter(Name="GetCancelled")] public MainLayout.GetCancelledT GetCancelled { get; set; }

	private string RomMessage = "Upload Rom:";
	private bool RememberROM = false;


	private byte[] _fileData;
	private FF1Rom _rom;

	private string _seed;
	private string _seedInputClass = "";
	private string _resourcePackHost = "https://wiki.finalfantasyrandomizer.com/resource-packs/";
	private string _encodedResourcePackUrl = "";

	protected override async void OnInitialized()
	{
		Flags.PropertyChanged += async (sender, args) => await SetQueryString();

		var uri = new Uri(NavigationManager.Uri);
		if (QueryHelpers.ParseQuery(uri.Query).TryGetValue("s", out var seed))
		{
			_seed = seed.Single();
			UpdateAction?.Invoke("UpdateSeed", _seed);
		}
		else
		{
			await OnNewSeed(null);
		}

		if (QueryHelpers.ParseQuery(uri.Query).TryGetValue("f", out var flags))
		{
			TrySetFlags(flags.First());
		}

		if (QueryHelpers.ParseQuery(uri.Query).TryGetValue("rp", out var encodedResourcePackUrl))
		{
			// convert from Flagstring Base64 alphabet
			string encoded = encodedResourcePackUrl.Single()
				.Replace(".","+")
				.Replace("-","/")
				.Replace("_","=");
			string basename = Encoding.UTF8.GetString(Convert.FromBase64String(encoded));
			UpdateAction?.Invoke("UpdateResourcePackUrl", encoded);
			await TrySetResourcePackUrl(_resourcePackHost + basename);
		}

		var romfile = await JSRuntime.InvokeAsync<string>("getFFRPreferences", "file");
		if (romfile != null) {
			LoadLastROM(romfile);
		}
	}

	void LoadLastROM(string encoded)
	{
		RememberROM = encoded != null && encoded.Length > 0;
		if (RememberROM)
		{
			SetFileData(encoded);
			RomMessage = "Using Remembered ROM.";
			SetStatusMessage(StatusMessage + " Remembered last used ROM.");
		}
	}

	async Task OnFileChanged(ChangeEventArgs e)
	{
		var encoded = await JSRuntime.InvokeAsync<string>("handleFileSelect", "fileInput");
		RomMessage = "Using Selected ROM.";
		SetFileData(encoded);

		if (RememberROM)
		{
			await JSRuntime.InvokeVoidAsync("setFFRPreferences",
									"file",
									encoded);
		}
	}

	void SetFileData(string encoded)
	{
		_fileData = Convert.FromBase64String(encoded);
		using (var stream = new MemoryStream(_fileData))
		{
			FF1Rom temprom = new FF1Rom(stream);
			if (temprom.HeaderLength != 16)
			{
				RomMessage = "ROM header length is incorrect, try a different ROM";
				return;
			}
			try
			{

				temprom.AssureSafe();
			}
			catch (FF1Lib.FF1Rom.TournamentSafeException)
			{
				RomMessage = "Detected ROM hash does not match the expected hash.\nResults may vary.";
			}

		}
	}

	public async Task SetQueryString()
	{
		string[] args = new string[3] { _seed, Flags.Encoded, _encodedResourcePackUrl };

		await JSRuntime.InvokeAsync<Task>("updateHistory", args);
	}

	async Task OnSeedInputChanged(ChangeEventArgs e)
	{
		await ValidateSeed((string)e.Value);
	}

	async Task ValidateSeed(string seed)
	{
		if (seed == _seed)
			return;

		if (seed.Length > 8)
		{
			_seedInputClass = "is-error";
			return;
		}

		_seed = seed;
		try
		{
			Blob.FromHex(_seed);
			_seed = seed.PadLeft(8, '0');
			_seedInputClass = "";
			UpdateAction?.Invoke("UpdateSeed", _seed);
			await SetQueryString();
		}
		catch (Exception)
		{
			_seedInputClass = "is-error";
		}
	}

	async Task OnNewSeed(MouseEventArgs e)
	{
		await ValidateSeed(Blob.Random(4).ToHex());
		StateHasChanged();
	}

	void OnCopyToClipboard(MouseEventArgs e)
	{
		SetStatusMessage("URL Copied To Clipboard.");
		StateHasChanged();

		JSRuntime.InvokeAsync<object>("copyLocation");
	}

	void OnFlagsInputChanged(ChangeEventArgs e)
	{
		TrySetFlags((string)e.Value);
	}

	void TrySetFlags(string flags)
	{
		try
		{
			Flags.ReadFromFlags(FF1Lib.Flags.DecodeFlagsText(flags));
			UpdateAction?.Invoke("UpdateFlagstring", _seed);
			SetStatusMessage("Successfully imported Flags.");
		}
		catch (Exception)
		{
			SetStatusMessage("Invalid Flags String.");
		}
	}

	void OnPlayerNameChanged(ChangeEventArgs e)
	{
		string playername = (e.Value as string);

		Preferences.PlayerName = playername.Length > 16 ? playername.Substring(0, 16) : playername;

		UpdateAction?.Invoke("UpdateFlagstring","");
	}

	async Task OnImportResourcePack(ChangeEventArgs e) {
		try 
		{
			string content = await JSRuntime.InvokeAsync<string>("handleFileSelect", "importResourcePackInput");
			if (content == null || content == "") { return; }
			SetResourcePack(content);
			ResourcePackUrl = "";
			_encodedResourcePackUrl = "";
		} 
		catch (Exception x)
		{
			Console.WriteLine(x.ToString());
			SetStatusMessage("Failed to Load Resource Pack");
		}
		await SetQueryString();
		StateHasChanged();
	}

	async Task OnResourcePackUrlChanged(ChangeEventArgs e)
	{
		await TrySetResourcePackUrl(e.Value as string);
		
	}

	async Task TrySetResourcePackUrl(string resourcePackUrl)
	{
		ResourcePackUrl = resourcePackUrl;
		string content = null;
		if (resourcePackUrl == null || resourcePackUrl == "")
		{
			_encodedResourcePackUrl = "";
			SetStatusMessage("Cleared Resource Pack URL");
		}
		else if (!resourcePackUrl.StartsWith(_resourcePackHost))
		{
			_encodedResourcePackUrl = "";
			SetStatusMessage("Invalid Resource Pack URL.<br>Resource packs are hosted on the wiki site.");
		}
		else if (!resourcePackUrl.EndsWith(".zip"))
		{
			_encodedResourcePackUrl = "";
			SetStatusMessage("Invalid Resource Pack URL.<br>Resource Pack must be a .zip file.");
		}
		else 
		{
			try
			{
				byte[] bytes = await Http.GetByteArrayAsync(resourcePackUrl);
				content = Convert.ToBase64String(bytes);
				
				string basename = resourcePackUrl.Replace(_resourcePackHost,"");
				// match the Flagstring Base64 alphabet
				_encodedResourcePackUrl = Convert.ToBase64String(Encoding.UTF8.GetBytes(basename))
					.Replace("+",".")
					.Replace("/","-")
					.Replace("=","_");
				UpdateAction?.Invoke("UpdateResourcePackUrl",_encodedResourcePackUrl);
				if (!Flags.BlindSeed)
				{	
					await JSRuntime.InvokeAsync<Task>("clearFileSelect","importResourcePackInput");
				}
				
			}
			catch (Exception x)
			{
				Console.WriteLine(x.ToString());
				SetStatusMessage("Invalid Resource Pack URL");
			}
		}
		SetResourcePack(content);
		await SetQueryString();
		
	}

	void SetResourcePack(string content)
	{
		if (content == null || content == "")
		{
			Flags.ResourcePack = null;
			return;
		}
		using (MemoryStream stream = new MemoryStream(Convert.FromBase64String(content)))
		{
			try
			{
				var archive = new ZipArchive(stream);
				var entries = archive.Entries;
			}
			catch (Exception x)
			{
				Console.WriteLine(x.ToString());
				SetStatusMessage("Resource Pack not valid zip file.");
				Flags.ResourcePack = "";
				return;
			}
			Flags.LoadResourcePackFlags(stream);
		}
		Flags.ResourcePack = content;
		UpdateAction?.Invoke("UpdateFlagstring", "");
		if (!Flags.BlindSeed)
		{
			SetStatusMessage("Successfully imported Resource Pack");
		}
		StateHasChanged();
	}

	async Task OnClearResourcePackUrl()
	{
		await TrySetResourcePackUrl(resourcePackUrl: "");
	}

	public void CollapseTriStates() {
		if (_fileData == null)
		{
			SetStatusMessage("Reveal Failed: No ROM File Selected!");
			StateHasChanged();
			return;
		}

		//All of this is needed to convert the tristate flags.
		//A better way would probably be to pull the rng initialization out of the rom class.
		//Update it as flags/seed change then give it back to rom during seed gen.
		using (var stream = new MemoryStream(_fileData))
		{
			_rom = new FF1Rom(stream);
		}
		Flags flagsForRng = Flags.ShallowCopy();
		_rom.GenerateRng(flagsForRng, Blob.FromHex(_seed));
		Flags = FF1Lib.Flags.ConvertAllTriState(flagsForRng, FF1Lib.FF1Rom.rng);
		
		//Reloads page with new flags
		//Surely there's a better way to do this
		NavigationManager.NavigateTo(NavigationManager.BaseUri + "?s=" + _seed + "&f=" + Flags.Encoded, true);
	}

	async Task OnRandomize(MouseEventArgs e)
	{
		if (_fileData == null)
		{
			SetStatusMessage("Generate Failed: No ROM File Selected!");
			StateHasChanged();
			return;
		}

		if (Flags.OwMapExchange == OwMapExchanges.ImportCustomMap && Flags.ReplacementMap == null) {
			SetStatusMessage("Generate Failed: Must import a map or choose a different overworld option");
			StateHasChanged();
			return;
		}

		using (var stream = new MemoryStream(_fileData))
		{
			_rom = new FF1Rom(stream);
		}

		if (RememberROM)
		{
			await LocalStorage.SetItemAsync("file", Convert.ToBase64String(_fileData));
		}
		else
		{
			await LocalStorage.RemoveItemAsync("file");
		}

		SetStatusMessage("Generating Final Fantasy Randomizer ROM ... Please Wait ... ");
		StateHasChanged();

		//await Task.Run(DoRandomize);
		await DoRandomize();
	}

	string warnings = "";
	string lastMessage = "";
	string modalContent = "";

	async Task Progress(int step, int max, string message) {
		if (message.StartsWith("WARNING")) {
			warnings = warnings + "<br>" + message;
			modalContent = $"Progress: {step}/{max}<br>{warnings}";
		} else {
			if (message != "") {
				lastMessage = message;
			}
			modalContent = $"Progress: {step}/{max}<br>{warnings}<br>{lastMessage}";
		}
		SetModalContent(modalContent + "<br>" + StatusMessage);
		StateHasChanged();
		await Task.Delay(1);
		if (GetCancelled()) {
			throw new OperationCanceledException();
		}
	}

	async Task DoRandomize()
	{
		Blob seed;
		try
		{
			if (_seed.Length != 8)
			{
				throw new Exception();
			}
			seed = Blob.FromHex(_seed);
		}
		catch (Exception)
		{
			SetStatusMessage("Generate Failed: Invalid Seed Format");
			StateHasChanged();
			return;
		}

		try
		{
			Utilities.SpoilerCache = string.Empty;
			Utilities.FlagCache = string.Empty;
			Utilities.ProcgenWaterfallCache = string.Empty;

			_rom.ProgressCallback = this.Progress;

			this.warnings = "";
			SetModalContent("");
			ShowModal(true);
			SetGenerating(true);

			Flags tempFlags = await _rom.Randomize(seed, Flags, Preferences);

			if (Flags.TriState){
				Flags = tempFlags;
				Flagstring = Flags.Encoded;
			}
			
			string BlursingsText = "<details><summary>Class Blursings:</summary><p>" + ("\n\n" + _rom.SpoilBlursings())
				.Replace("\n\nFighter", "<br><br><b>Fighter</b>")
				.Replace("\n\nThief", "<br><br><b>Thief</b>")
				.Replace("\n\nBlack Belt", "<br><br><b>Black Belt</b>")
				.Replace("\n\nRed Mage", "<br><br><b>Red Mage</b>")
				.Replace("\n\nWhite Mage", "<br><br><b>White Mage</b>")
				.Replace("\n\nBlack Mage", "<br><br><b>Black Mage</b>")
				.Replace("BONUS", "<b>BONUS</b>")
				.Replace("MALUS", "<b>MALUS</b>")
				.Replace("\n ","<br>&nbsp;&nbsp;").Replace("\n","<br>")+ "</p></details>";

			var data = new byte[512 * 1024 + 16];
			using (var stream = new MemoryStream(data, true))
			{
				_rom.Save(stream);
			}

			var encoded = Convert.ToBase64String(data);

			SetStatusMessage(StatusMessage + "SUCCESS!");

			if (Flags.Spoilers && Utilities.SpoilerCache.Length > 0)
			{
				SetStatusMessage(StatusMessage + " Downloading ROM and spoiler log.");
			}
			else if (Flags.Spoilers && Utilities.SpoilerCache.Length == 0)
			{
				SetStatusMessage(StatusMessage + " No spoilers have been generated to download.");
			}

			if (Preferences.PrintBlursings)
			{
				SetStatusMessage(StatusMessage + "<br><br>" + BlursingsText);
			}

			StateHasChanged();

			await JSRuntime.InvokeAsync<object>("downloadFile", $"FFR_{_seed}_{_rom.GetHash()}.nes", encoded);

			if(Flags.Spoilers && Utilities.SpoilerCache.Length > 0)
			{
				var encodedSpoiler = Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(Utilities.SpoilerCache));
				await JSRuntime.InvokeVoidAsync("downloadFile", $"Spoiler_{_seed}_{_rom.GetHash()}.txt", encodedSpoiler);
			}

			if(Flags.ProcgenWaterfallSpoiler && Utilities.ProcgenWaterfallCache.Length > 0)
			{
				var encodedSpoiler = Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(Utilities.ProcgenWaterfallCache));
				await JSRuntime.InvokeVoidAsync("downloadFile", $"WaterfallSpoiler_{_seed}_{_rom.GetHash()}.txt", encodedSpoiler);
			}

			if (Flags.Archipelago)
			{
				var encodedSpoiler = Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(Utilities.ArchipelagoCache));
				await JSRuntime.InvokeVoidAsync("downloadFile", $"{Preferences.PlayerName}_{_seed}_{_rom.GetHash()}.yaml", encodedSpoiler);
			}

		} catch (FailedToGenerate e) {
			SetStatusMessage(StatusMessage + "FAILURE: " + e.Message);
		}
		catch (Exception e)
		{
			SetStatusMessage(StatusMessage + "FAILURE: " + e.Message);
			modalContent = $"{modalContent}<br><br>{e.ToString().Replace("\n", "<br>")}<br>";
			Console.WriteLine(e.ToString());
		} finally {
			SetModalContent(modalContent + "<br>" + StatusMessage);
			SetGenerating(false);
		}

		StateHasChanged();
	}


}
